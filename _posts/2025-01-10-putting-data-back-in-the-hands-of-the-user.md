---
layout: post
title: Putting data back in the hands of the user
date: 2024-12-20
---
Relational databases are in their sixth decade, and the database community is understandably celebrating and reflecting its accomplishments. In two wonderful pieces, Donald Chamberlin shared [his perspective on the past half-century](https://cacm.acm.org/research/50-years-of-queries/), and Eugene Wu shared thoughts on [where we can go from here](https://wp.sigmod.org/?p=3801). At a time of reflection on relational database management systems as a largely solved problem, I'm struck by a painful contrast: database technology is more powerful than it's ever been, but the average person's relationship with their data is in the worst state its ever been.

The fundamental problem is that in using most modern consumer-oriented applications, we lose control of the data we share with those applications. In creating documents, writing emails, or tracking our exercise or other activities, we share data with an application that's useful for a particular purpose, but also allow the data live in a database controlled by the application's owner. With the data outside of our control, it can then be restricted, lost, leaked, sold, resold, and exploited. The groups that control these databases accrue most of the benefits, and we accrue most of the costs.

It's time to put users back in control of data they share with applications. To accomplish this, we'll want to make two elements of the predominant consumer-oriented application model easier:
* It should be as easy for a user to create their own database as it is for them to create a document or send an email.
* It should be easy for an application to store data a user shares in a database that the user created and controls rather than in a database controlled by the application's developer.

In this post, I'll first describe how we got here and what the world looks like today. I'll then propose a different model, where people maintain control over databases that applications use to store their data. Finally, I'll close with some research directions that will ease the way for people to maintain control over their data.

## How it works today: your data goes in, and never comes out
Historically, databases were designed to track things that were fully controlled by an enterprise. In [Ted Codd's seminal 1974 paper on relational databases](https://dl.acm.org/doi/pdf/10.1145/357980.358007), his example use case is that of a company tracking an inventory of parts required for various projects. In such a world, the user is an analyst or project manager updating and analyzing information that likely belongs to the company. The company wants a complete view of its inventory, and to wants to control who, how, and when specific users access or change this information.

In the late 1990s and early 2000s, with the rise of consumer-oriented database-backed applications, and the question of who should control the data became more nuanced. As consumers started to send emails, create documents, take photos, and track their runs/meals/activities in applications, developers continued to use the centralized model of data storage, placing all consumer-generated data in a single centralized database containing all of their users' data:
![A hand-drawn cartoon diagram in which a user provides data to an application, which inserts it into a database. The database acknowledges the insertion to the application, which acknowledges the insertion to the user.](/assets/images/putting-data-back-in-the-hands-of-the-user/traditional-insert.png)

With time, consumers hit unpleasant surprises: applications limited what they could do with data they previously shared, and the data started being used in ways consumers didn't expect. Because data they generated was stored in someone else's database, users felt a loss of control over their data. They couldn't delete it, visualize it in a different way, or use it in another application. If the user wanted to get all of the data they previously shared with the application, there's no guarantee the application would allow that:
![A hand-drawn cartoon diagram in which a user requests their data for an application, which responds "Nope!"](/assets/images/putting-data-back-in-the-hands-of-the-user/traditional-query.png)

In this traditional centralized storage model, the owner of the database retains most of the power. They can restrict the user's access to their own data. They can delete the data. They can sell the data to a third party. They might introduce a bug that allows other people to access the data. They might get compromised. Or they can avoid all of these mistakes just to be acquired, and have the new management change course.

That's the state of the world in 2025: most everyone agrees that you should maintain some control over data you share with applications, but most everyone knows that our 1970's-era architecture makes that challenging or impossible.

To be clear, some data should still be stored in centralized databases with restricted user access. Inventory is a great example: the business selling shoes needs to track how many of each shoe it has left, whereas the consumer only needs to know whether there are any shoes left to buy. A more nuanced example is click tracking and usage logs. Say a user consents to an application tracking their activity while editing a document (hopefully in exchange for something of value, like recommendations or an improved experience). The user's click data is not the key focus of the user, who likely just wants to maintain control over their document, and it is most useful in aggregate across multiple users. If usage logs exist at all, they should probably be stored and analyzed in a centralized way that restricts user access.

It boils down to this: when users share information (e.g., "I walked here" or "I ate that cake") with an application, or when users rely on an application to create some work product (e.g., a document or email), they expect to maintain access to and control over the data and content they shared. By relying on an enterprise-centered architecture from the 1970s, users don't get the control they expect. In the next section, we'll see how rearrange the traditional architecture to put users back in control.
## How it should work: data we care about lives in databases we control
Let's modify the architecture of the application above. What if it was easy for a user to create a personal database and authorize the application to access it? The user could maintain control over the database, and the web application would gain credentials to the database for as long as the user wished. An application might have access to many users' databases, and would interact with each user's database with credentials that the user authorized it to have. Here's a user sharing the credentials to their database with an application:
![A hand-drawn cartoon diagram in which both the user and the application have a database. The user authenticates their database to the application, which inserts it into its database. The application's database acknowledges the insertion to the application, which acknowledges the insertion to the user.](/assets/images/putting-data-back-in-the-hands-of-the-user/proposed-database.png)
TODO: acknowledge that creating/storing databases needs to be easier. Acknowledge that sharing database requires OAuth2-like functionality that doesn't today exist for most/any databases.

With those stored credentials, the application can service future requests from this user by querying the user's database using the stored credentials:
![A hand-drawn cartoon diagram in which a user provides data to an application, which looks up that user's key in the application database. The application then, which inserts data into the user's database. The user's database acknowledges the insertion to the application, which acknowledges the insertion to the user.](/assets/images/putting-data-back-in-the-hands-of-the-user/proposed-insert.png)

As long as the application continues to provide utility and the application owner keeps up their end of the bargain, the user can continue to authorize the application to access their data in their database. Our user maintains control over their data, and can authorize multiple applications to interact with their database. They can also decide it's time to revoke access to some of those applications. Unlike in the traditional model, the user doesn't have to ask in order to access any of their previously shared data:
![A hand-drawn cartoon diagram in which a user can request their data from their database, which responds "HERE!" without any interaction with the application.](/assets/images/putting-data-back-in-the-hands-of-the-user/proposed-query.png)

The user is ultimately in control of who accesses the data in their database. They can connect their database to other applications, or modify their own data or visualize it in ways any one application doesn't allow.

This model doesn't solve all problems, and in particular, it's not some infallible privacy solution. The user still shares data with a third-party application, and that application can do unsavory things with it like leaking data inadvertently or by design. A bug could still wipe out or corrupt a user's database, and multiple applications might interact in unexpected or undesirable ways. But the ultimate source of truth for the application is a database controlled by the user, giving the user more choice, and application owners slightly more accountability if they want to keep a long-term relationship with the user.

Put simply: in the future, your data should live in your database, giving you more control over what happens to that data.

## What would it take?
Any sane technologist at this point will explain to you that databases are HARD! They'd ask if you really expect *the average person* to spin up a database? To back it up? To ensure it's available? To monitor how their data is used and enforce their own policies?

Yes, I expect the average person to do all of these things, but not by technical mastery or sweating the details. The database community should provide users with technology that is designed and purpose-built to grant users sovereignty over their data. Here are a few of the hard problems the database community would have to solve:
* *Easy database creation and maintenance*. None of this works until it's as easy to create a database as it is to create a Google document or a GitHub repository. A side project of mine, [ayb](https://github.com/marcua/ayb?tab=readme-ov-file#running-a-client) is a step toward this goal, though much more work in this space is required to allow any user to spin up a database (with good availability and backups) to share with an application.
* *Authorization and usable security*. Once a user creates their database, they have to share it with an application. How might we help users do this easily and securely?
* *Audit logs, provenance, and policies*. By sharing your database with an application, you're opening yourself up to leaks and side-channel attacks. Still, what sort of logging, provenance, and monitoring can we offer users so that they can tell when and how their data is accessed, and by whom? Are there ways to specify policies that restrict how an application uses your data?
* *Terms of data use*. When you sign up for a service that stores your data today, you agree to Terms of Service (TOS) that dictate how you must act in order to keep using the service and accessing your own data. If you controlled your own database, you'd be able to bring your own set of terms to the relationship: in order to access your data, an application owner would have to agree to your Terms of Data Use (TODU). How could we make it easier for users to pick these terms, and what could we provide in terms of guarantees or monitoring that the application is sticking to the terms?
* *Multi-user and collaboration*. One beneficial side effect of the traditional web application/database architecture is that, because all users are in one database, multi-user applications have a clear home for shared data. If everyone has their own database, it's more challenging to build applications around shared data. How might we make it easier to federate collaborators' databases?
* *Migrations*. It's complicated enough to change the schema of a database or migrate the data in the database as your application changes. How can we ease the burden on application developers whose application now has to be able to speak with multiple databases, each of which are at different stages of being migrated?
* *Performance, maybe*. Databases are typically quite close to the servers hosting an application. If database servers and application servers are not as collocated, round trips between the two will incur additional latency. I say *maybe* because modern applications generally rely on lots of third-party APIs, and so how bad it it really for an application to have to interact with a somewhat remote third-party database?

## People, not rows
The many decades of success that databases have seen are in large part thanks to their power to provide an abstraction that addresses a wide variety of problems. That abstraction of tables and rows is technically powerful, but it also distracts us from what lies beneath: the rows of a database often contain people, activities, and secrets. Let's keep building on the technical beauty that six decades of database research has provided, but let's not forget who we're building for: when databases contain people's information, let's help those people control their data.

*Thank you to Timothy Danford, Lydia Gu, and Eugene Wu for reading early versions of this blog post.*
